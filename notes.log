в начале проверку на количество перед выделением памяти

ft_printf("run for a: %d, b: %d\n", s->num, pair->num);	
	// ft_printf("%d - a m\n && %d b paired m)  ________ \n",
	
	// m(a, indx(a), m(a->pair, indx(a->pair)));

			ft_printf("a: %d | b: %d  we move up\n", s->num, pair->num);
		ft_printf("a index: %d | b index: %d  we move down\n", s->index, pair->index);

		ft_printf("for a %d and b %d | a_steps (%d) + b_steps (%d) - d (%d) = steps(%d)\n", 
				a->num, a->pair->num, a_steps, b_steps, d, steps);


		секс это безопасно



t_node *cpy_loop(t_node * dst, t_node *src, int size, int i)
{
	t_node *prev;

	prev = dst;
	dst->num = src->num;
	dst->index = src->index;
	dst->steps = 0;
	dst->pair = src->pair;
	if (i == size)
		return(dst);
	dst->next = (t_node *)ft_calloc(1, sizeof(t_node));
	if (!dst->next)
		return(NULL);
	dst = dst->next;
	dst->prev = prev;
	i++;
	return(dst);
}


t_node *copy_list(t_node *src, int size, t_data *_, int i)
{
  	t_node *start;
    t_node *dst;
    
	start = (t_node *)ft_calloc(1, sizeof(t_node));
        if (!start)
        return (error(MLC_ERR, _), NULL);
    dst = start;
	while (++i <= size)
	{
		dst = cpy_loop(dst, src, size, i);
			if (dst == NULL)
  				return (free_list(start), error(MLC_ERR, _), NULL);
		src = src->next;
	}
	if (i > 1)
	{
		dst->next = start;
		start->prev = dst;
	}
	else 
	{
		start->next = NULL;
		start->prev = NULL;
	}
	return (start);
}


void sort_3(t_data *_, int max)
{
	if (max == 1)
	{
		if (_->b && _->b_qty == 3)
			rb(_);
		else
			ra(_);
		sort_2(_);
	}	
	if (max == 2)
	{		
		if (_->b && _->b_qty == 3)
		{
			rb(_);
			rb(_);
		}
		else
		{
			ra(_);
			ra(_);
		}
		sort_2(_);
	}


	void back_to_a(t_data *_)
{
	while (_->b_qty > 1)
	{
	prt(_);
			roll_b_min_top(_);
			while (_->a->num <= _->b->num) // && ++i <= _->a_qty
				ra(_);
			if (_->b->num <= _->a->num)
				pa(_);
	}
	pa(_);
}